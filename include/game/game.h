#pragma once

#define __size 4

typedef struct {
  int call_every_ms; // should be mutiple of 10
  void (*handler)();
  volatile int counter;
} Event;

// https://tetris.wiki/Tetromino
typedef enum {
  SHAPE_I,
  SHAPE_O,
  SHAPE_T,
  SHAPE_S,
  SHAPE_Z,
  SHAPE_J,
  SHAPE_L
} Shape;

typedef enum {
  CYAN, // light blue
  YELLOW,
  PURPLE,
  GREEN,
  RED,
  BLUE,
  ORANGE,
  CLEAR
} Color;

// initial 0 angle for each piece will look like this: https://tetris.wiki/Tetromino
typedef enum {
  ANGLE_0,
  ANGLE_90,
  ANGLE_180,
  ANGLE_270
} Angle;

typedef struct {
  int x;
  int y;
} Point;

// dynamic piece in the board (should be one moving piece and one next spawn piece existed at a time)
typedef struct {
  Shape shape;
  Color color;
  Angle angle;
  Point center_point; // position of the center point, this is x, y position in the 2D array
} Piece;

// static block that have settle down (generated by the previous dynamic pieces)
typedef struct {
  Color color;
} Block;


enum Difficulty {
    EASY,
    MEDIUM,
    HARD
};


// Flow control
void handle_game_mode();
void _print_error_game_mode();
int _is_up_command();
int _is_down_command();
int _is_left_command();
int _is_right_command();
int _is_back_tick_command();
int _is_enter_or_space_command();
void _exit_game();
void _print_error_game_mode();
void _handle_welcome_screen_input();
void _init_game();
void _increase_current_piece();
void _spawn_random_piece_to(Piece *piece);
void _rotate_piece(Piece *piece);

// Drawing
void _draw_game_piece(Piece *piece);
void _clear_game_piece(Piece *piece);
void _draw_game_point(int x, int y, Color color);

void _draw_next_frame_piece(Piece *piece);
void _clear_next_frame_piece(Piece *piece);
void _draw_next_frame_point(int x, int y, Color color);
void _adjust_x_y_for_center_drawing_next_frame(int *x, int *y, Shape shape);

void _draw_game_scores(unsigned int score);

// Utils
Point* _get_init_points(Piece *piece);
Point _get_init_center_point(Piece *piece);
Point* _copy_piece_angle_0_points_to_buffer(Piece *piece, Point buffer[]);
void _copy_piece_rotated_points_to_buffer(Piece *piece, Point buffer[]);
void _adjust_center_point_if_overflow(Piece *piece, Point points[]);
int _get_angle_multiplier_sin(Angle angle);
int _get_angle_multiplier_cos(Angle angle);

